{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {import('unist-util-is').Type} Type\n * @typedef {import('unist-util-is').Props} Props\n * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything\n */\n\nimport { convert } from 'unist-util-is';\nexport var findAfter =\n/**\n * @type {(\n *  (<T extends Node>(node: Parent, index: Node|number, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>) => T|null) &\n *  ((node: Parent, index: Node|number, test?: null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => Node|null)\n * )}\n */\n\n/**\n * @param {Parent} parent Parent node\n * @param {Node|number} index Child of `parent`, or it’s index\n * @param {null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} [test] is-compatible test (such as a type)\n * @returns {Node|null}\n */\nfunction (parent, index, test) {\n  var is = convert(test);\n  if (!parent || !parent.type || !parent.children) {\n    throw new Error('Expected parent node');\n  }\n  if (typeof index === 'number') {\n    if (index < 0 || index === Number.POSITIVE_INFINITY) {\n      throw new Error('Expected positive finite number as index');\n    }\n  } else {\n    index = parent.children.indexOf(index);\n    if (index < 0) {\n      throw new Error('Expected child node or index');\n    }\n  }\n  while (++index < parent.children.length) {\n    if (is(parent.children[index], index, parent)) {\n      return parent.children[index];\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["convert","findAfter","parent","index","test","is","type","children","Error","Number","POSITIVE_INFINITY","indexOf","length"],"sources":["D:/Ethan_Webb_Personal_Website/ethan-website/node_modules/unist-util-find-after/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {import('unist-util-is').Type} Type\n * @typedef {import('unist-util-is').Props} Props\n * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything\n */\n\nimport {convert} from 'unist-util-is'\n\nexport var findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node|number, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>) => T|null) &\n   *  ((node: Parent, index: Node|number, test?: null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => Node|null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent Parent node\n     * @param {Node|number} index Child of `parent`, or it’s index\n     * @param {null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} [test] is-compatible test (such as a type)\n     * @returns {Node|null}\n     */\n    function (parent, index, test) {\n      var is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,OAAO,QAAO,eAAe;AAErC,OAAO,IAAIC,SAAS;AAClB;AACF;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACI,UAAUC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAE;EAC7B,IAAIC,EAAE,GAAGL,OAAO,CAACI,IAAI,CAAC;EAEtB,IAAI,CAACF,MAAM,IAAI,CAACA,MAAM,CAACI,IAAI,IAAI,CAACJ,MAAM,CAACK,QAAQ,EAAE;IAC/C,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;EACzC;EAEA,IAAI,OAAOL,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,KAAKM,MAAM,CAACC,iBAAiB,EAAE;MACnD,MAAM,IAAIF,KAAK,CAAC,0CAA0C,CAAC;IAC7D;EACF,CAAC,MAAM;IACLL,KAAK,GAAGD,MAAM,CAACK,QAAQ,CAACI,OAAO,CAACR,KAAK,CAAC;IAEtC,IAAIA,KAAK,GAAG,CAAC,EAAE;MACb,MAAM,IAAIK,KAAK,CAAC,8BAA8B,CAAC;IACjD;EACF;EAEA,OAAO,EAAEL,KAAK,GAAGD,MAAM,CAACK,QAAQ,CAACK,MAAM,EAAE;IACvC,IAAIP,EAAE,CAACH,MAAM,CAACK,QAAQ,CAACJ,KAAK,CAAC,EAAEA,KAAK,EAAED,MAAM,CAAC,EAAE;MAC7C,OAAOA,MAAM,CAACK,QAAQ,CAACJ,KAAK,CAAC;IAC/B;EACF;EAEA,OAAO,IAAI;AACb,CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}