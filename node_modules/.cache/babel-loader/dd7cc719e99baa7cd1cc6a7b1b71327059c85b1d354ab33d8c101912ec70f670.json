{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n};\n\n/** @type {Construct} */\nconst nonLazyLine = {\n  tokenize: tokenizeNonLazyLine,\n  partial: true\n};\n\n/** @type {Tokenizer} */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`');\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /** @type {State} */\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    effects.exit('mathFlowFenceSequence');\n    return sizeOpen < 2 ? nok(code) : factorySpace(effects, metaOpen, types.whitespace)(code);\n  }\n\n  /** @type {State} */\n  function metaOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return meta(code);\n  }\n\n  /** @type {State} */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit('mathFlowFenceMeta');\n      return openAfter(code);\n    }\n    if (code === codes.dollarSign) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n\n  /** @type {State} */\n  function openAfter(code) {\n    effects.exit('mathFlowFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n\n  /** @type {State} */\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt({\n        tokenize: tokenizeClosingFence,\n        partial: true\n      }, after, initialSize ? factorySpace(effects, contentStart, types.linePrefix, initialSize + 1) : contentStart), after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentContinue(code);\n  }\n\n  /** @type {State} */\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return contentStart(code);\n    }\n    effects.consume(code);\n    return contentContinue;\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return factorySpace(effects, closingPrefixAfter, types.linePrefix, constants.tabSize);\n\n    /** @type {State} */\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return closingSequence(code);\n    }\n\n    /** @type {State} */\n    function closingSequence(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n      if (size < sizeOpen) return nok(code);\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code);\n    }\n\n    /** @type {State} */\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","codes","constants","types","mathFlow","tokenize","tokenizeMathFenced","concrete","nonLazyLine","tokenizeNonLazyLine","partial","effects","nok","self","tail","events","length","initialSize","type","linePrefix","sliceSerialize","sizeOpen","start","code","dollarSign","enter","sequenceOpen","consume","exit","metaOpen","whitespace","eof","openAfter","chunkString","contentType","contentTypeString","meta","interrupt","contentStart","after","attempt","tokenizeClosingFence","contentContinue","size","closingPrefixAfter","tabSize","closingSequence","closingSequenceEnd","lineEnding","lineStart","parser","lazy","now","line"],"sources":["D:/Ethan_Webb_Personal_Website/ethan-website/node_modules/micromark-extension-math/dev/lib/math-flow.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyLine = {tokenize: tokenizeNonLazyLine, partial: true}\n\n/** @type {Tokenizer} */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`')\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /** @type {State} */\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('mathFlowFenceSequence')\n    return sizeOpen < 2\n      ? nok(code)\n      : factorySpace(effects, metaOpen, types.whitespace)(code)\n  }\n\n  /** @type {State} */\n  function metaOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('mathFlowFenceMeta')\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /** @type {State} */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit('mathFlowFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === codes.dollarSign) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n\n  /** @type {State} */\n  function openAfter(code) {\n    effects.exit('mathFlowFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n\n  /** @type {State} */\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          {tokenize: tokenizeClosingFence, partial: true},\n          after,\n          initialSize\n            ? factorySpace(\n                effects,\n                contentStart,\n                types.linePrefix,\n                initialSize + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('mathFlowValue')\n    return contentContinue(code)\n  }\n\n  /** @type {State} */\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    return factorySpace(\n      effects,\n      closingPrefixAfter,\n      types.linePrefix,\n      constants.tabSize\n    )\n\n    /** @type {State} */\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return closingSequence(code)\n    }\n\n    /** @type {State} */\n    function closingSequence(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code)\n    }\n\n    /** @type {State} */\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}