{"ast":null,"code":"/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('./complex-types').Math} Math\n * @typedef {import('./complex-types').InlineMath} InlineMath\n *\n * @typedef ToOptions\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\n\nimport { longestStreak } from 'longest-streak';\nimport { safe } from 'mdast-util-to-markdown/lib/util/safe.js';\nimport { track } from 'mdast-util-to-markdown/lib/util/track.js';\n\n/**\n * @returns {FromMarkdownExtension}\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlow(token) {\n    this.enter({\n      type: 'math',\n      meta: null,\n      value: '',\n      data: {\n        hName: 'div',\n        hProperties: {\n          className: ['math', 'math-display']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node = /** @type {Math} */this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return;\n    this.buffer();\n    this.setData('mathFlowInside', true);\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    const node = /** @type {Math} */this.exit(token);\n    node.value = data;\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data;\n    this.setData('mathFlowInside');\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathText(token) {\n    this.enter({\n      type: 'inlineMath',\n      value: '',\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: ['math', 'math-inline']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n    this.buffer();\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathText(token) {\n    const data = this.resume();\n    const node = /** @type {Math} */this.exit(token);\n    node.value = data;\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data;\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\n\n/**\n * @param {ToOptions} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function mathToMarkdown() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let single = options.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: ['mathFlowMeta']\n    }, {\n      character: '\\r',\n      inConstruct: ['mathFlowMeta']\n    }, single ? {\n      character: '$',\n      inConstruct: ['mathFlowMeta', 'phrasing']\n    } : {\n      character: '$',\n      after: '\\\\$',\n      inConstruct: ['mathFlowMeta', 'phrasing']\n    }, {\n      atBreak: true,\n      character: '$',\n      after: '\\\\$'\n    }],\n    handlers: {\n      math,\n      inlineMath\n    }\n  };\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || '';\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2));\n    const exit = context.enter('mathFlow');\n    const tracker = track(safeOptions);\n    let value = tracker.move(sequence);\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta');\n      value += tracker.move(safe(context, node.meta, {\n        ...tracker.current(),\n        before: value,\n        after: ' ',\n        encode: ['$']\n      }));\n      subexit();\n    }\n    value += tracker.move('\\n');\n    if (raw) {\n      value += tracker.move(raw + '\\n');\n    }\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  function inlineMath(node) {\n    const value = node.value || '';\n    let size = 1;\n    let pad = '';\n    if (!single) size++;\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\n      size++;\n    }\n\n    // If this is not just spaces or eols (tabs don’t count), and either the first\n    // or last character are a space, eol, or dollar sign, then pad with spaces.\n    if (/[^ \\r\\n]/.test(value) && (/[ \\r\\n$]/.test(value.charAt(0)) || /[ \\r\\n$]/.test(value.charAt(value.length - 1)))) {\n      pad = ' ';\n    }\n    const sequence = '$'.repeat(size);\n    return sequence + pad + value + pad + sequence;\n  }\n\n  /** @type {ToMarkdownHandle} */\n  function inlineMathPeek() {\n    return '$';\n  }\n}","map":{"version":3,"names":["longestStreak","safe","track","mathFromMarkdown","enter","mathFlow","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","mathText","enterMathText","exit","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","token","type","meta","value","data","hName","hProperties","className","hChildren","buffer","resume","node","stack","length","getData","setData","replace","config","call","mathToMarkdown","options","single","singleDollarTextMath","undefined","inlineMath","peek","inlineMathPeek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","context","safeOptions","raw","sequence","repeat","Math","max","tracker","move","subexit","current","before","encode","size","pad","RegExp","test","charAt"],"sources":["D:/Ethan_Webb_Personal_Website/ethan-website/node_modules/mdast-util-math/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('./complex-types').Math} Math\n * @typedef {import('./complex-types').InlineMath} InlineMath\n *\n * @typedef ToOptions\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/**\n * @returns {FromMarkdownExtension}\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * @param {ToOptions} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function mathToMarkdown(options = {}) {\n  let single = options.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      single\n        ? {character: '$', inConstruct: ['mathFlowMeta', 'phrasing']}\n        : {\n            character: '$',\n            after: '\\\\$',\n            inConstruct: ['mathFlowMeta', 'phrasing']\n          },\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    const tracker = track(safeOptions)\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          ...tracker.current(),\n          before: value,\n          after: ' ',\n          encode: ['$']\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  function inlineMath(node) {\n    const value = node.value || ''\n    let size = 1\n    let pad = ''\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    // If this is not just spaces or eols (tabs don’t count), and either the first\n    // or last character are a space, eol, or dollar sign, then pad with spaces.\n    if (\n      /[^ \\r\\n]/.test(value) &&\n      (/[ \\r\\n$]/.test(value.charAt(0)) ||\n        /[ \\r\\n$]/.test(value.charAt(value.length - 1)))\n    ) {\n      pad = ' '\n    }\n\n    const sequence = '$'.repeat(size)\n    return sequence + pad + value + pad + sequence\n  }\n\n  /** @type {ToMarkdownHandle} */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}